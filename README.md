# CUDA. Задача разработки программы для поиска максимального значения среди минимальных элементов строк матрицы (номер 5)

Рассматриваются квадратные матрицы.

Решение задачи поиска максимума из минимумов строк решается с помощью разделения поиска минимума в строке по потокам, то есть запускается N потоков, где N это размер матрицы. Каждый поток ищет минимум в строке, номер которой соответствует номеру потока. В каждом потоке сравнивается больше ли текущий минимум в строке числа, отражающего максимум из минимумов рассмотренных ранее строк.

Сравним работу CUDA (слева) и OpenMP (справа), сравнивается имеенно время занимаемое процессом поиска максимума в матрице:

1) Видим, что уже при средних размерах матрицы (1024) выполнение с CUDA занимает меньше времени.

![image](https://user-images.githubusercontent.com/58008126/226370259-50c9265a-b1fa-4253-bafa-44a7e2437044.png)


2) При достаточно больших матрицах (размер 10240) преимущество в скорости с CUDA только растёт.

![image](https://user-images.githubusercontent.com/58008126/226370605-39143af8-6f50-4c1f-9602-4309512a3762.png)

Хоть CUDA и работает быстрее последовательно выполненной программы, но всё равно остаётся примерно на одном уровне с многопоточным выполнением на процессоре.

Можно сделать вывод, что обработка средних и больших объёмов данных горозда быстрее на CUDA, чем на процессоре при последоваетельном выполнении, и примерно на таком же уровне как на процессоре с многопоточностью. Есть у CUDA и минус, он заключается в ограничении обрабатываемого объёма данных (в моём случае точно). Проблема в том, что объём видеопамяти гараздо меньше, чем объём оперативной памяти.


